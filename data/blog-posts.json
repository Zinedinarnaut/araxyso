[
  {
    "id": "1",
    "title": "Apple Foundation Course – Design & Coding Experience",
    "excerpt": "The Apple Foundation Course was a three-week program where my team designed and built an iOS app using SwiftUI in Xcode, collaborating through research, design, and development. \uD83D\uDE80",
    "content": "The Apple Foundation Course was an intensive three-week program focused on design and coding, where my team and I collaborated to develop a fully functional iOS application using SwiftUI in Xcode.\n\nTeam & Roles\nI worked in a team of four, with a dynamic and flexible structure:\n\n2/3 researchers who gathered insights, defined user needs, and shaped the problem space.\n1 programmer (me) responsible for implementing the app in SwiftUI/Xcode and ensuring its functionality.\n4 designers, including myself, focused on UI/UX design, prototyping, and refining the app’s look and feel.\nCourse Phases\nWeek 1: Design & Research\n\nUsed Miro for brainstorming, wireframing, and planning the user experience.\nConducted research and ideation to define the app’s core functionality.\nDeveloped high-fidelity UI/UX prototypes.\nWeek 2: Coding & Development\n\nTransitioned from design to development, implementing the app using SwiftUI in Xcode.\nFocused on UI implementation, app logic, and debugging.\nIterated based on feedback to refine the user experience.\nWeek 3: Finalization & Presentation\n\nPolished the app by optimizing UI, fixing bugs, and preparing for launch.\nPrepared a presentation showcasing our design process, technical implementation, and final product.\nGraduated from the program with a final pitch and demonstration of our application.\nKey Takeaways\nGained hands-on experience in collaborative app development, from ideation to final implementation.\nStrengthened skills in SwiftUI, Xcode, and UI/UX design principles.\nLearned the importance of team dynamics and cross-functional collaboration in app development.",
    "author": "Zinny",
    "date": "2024-07-2",
    "tags": ["UTS", "Swift", "Apple Foundation"],
    "headerImage": "https://vvsjgfmxdtecylyv.public.blob.vercel-storage.com/content/image1-S7H2BSSy8aW9YIe493vK9dX2opIHhE.png",
    "contentImages": ["https://vvsjgfmxdtecylyv.public.blob.vercel-storage.com/content/image0-iiVacChkL5jIQzNTG9lu1aZmXbPDwF.png", "https://vvsjgfmxdtecylyv.public.blob.vercel-storage.com/content/AP1GczMRyZpdP4-A0MPCLb5ndo2HDVyj-kQFGUSvgHo-NmB4IeKcn-qOBbKsevnHDEik0jcSKVX0_znaEveb3tNgjJuIY_fLO6XpeTNegXvaAa0ycFiiC4v2N5vxvPLVjioH8Z_mMt65-75YNhtJS5ZPmkTow1756-h1317-s-no-gm-NH54uY2SZeDRl4eE8EXE5ekkwxUPIb.png"]
  },
  {
    "id": "2",
    "title": "Reverse Engineering a Caesar Cipher in Rust",
    "excerpt": "I dove into reverse engineering a Rust program that encrypts text using a Caesar cipher, uncovering its logic and learning key programming concepts. 🔍",
    "content": "Reverse engineering a Rust program was an exciting challenge that revealed the inner workings of a Caesar cipher—a simple encryption method that shifts letters in the alphabet. Here's how I analyzed the code, broke down its logic, and learned valuable lessons about Rust and reverse engineering.\n\n### Understanding the Program's Purpose\n\nThe program takes a string and a shift value as input, then outputs an encrypted string where each letter is shifted (e.g., 'A' with shift 3 becomes 'D'). Non-letters like spaces or punctuation remain unchanged. Running the code with inputs like 'Hello, World!' and shift 3 produced 'Khoor, Zruog!', hinting at a cipher.\n\nHere's a chart showing how the program processes characters:\n\n\`\`\`chartjs\n{\n  \"type\": \"pie\",\n  \"data\": {\n    \"labels\": [\"Letters Processed\", \"Non-Letters Skipped\"],\n    \"datasets\": [{\n      \"data\": [80, 20],\n      \"backgroundColor\": [\"#36A2EB\", \"#FF6384\"]\n    }]\n  },\n  \"options\": {\n    \"title\": {\n      \"display\": true,\n      \"text\": \"Character Processing Distribution (%)\"\n    }\n  }\n}\n\`\`\`\n\n### Breaking Down the Code\n\nThe program has two main parts: the `main` function for user interaction and the `encrypt` function for the cipher logic.\n\n#### The `main` Function\n\n\`\`\`rust\nuse std::io;\n\nfn main() {\n    println!(\"Enter text to encrypt:\");\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n    let text = input.trim();\n    \n    println!(\"Enter shift value:\");\n    let mut shift_input = String::new();\n    io::stdin().read_line(&mut shift_input).expect(\"Failed to read line\");\n    let shift: i32 = shift_input.trim().parse().expect(\"Invalid number\");\n    \n    let encrypted = encrypt(text, shift);\n    println!(\"Encrypted: {}\", encrypted);\n}\n\`\`\`\n\n#### The `encrypt` Function\n\n\`\`\`rust\nfn encrypt(text: &str, shift: i32) -> String {\n    text.chars()\n        .map(|c| {\n            if c.is_alphabetic() {\n                let base = if c.is_uppercase() { b'A' } else { b'a' } as char;\n                let shifted = (c as u8 - base as u8 + shift as u8) % 26;\n                (base as u8 + shifted) as char\n            } else {\n                c\n            }\n        })\n        .collect()\n}\n\`\`\`\n\nThe `encrypt` function uses Rust's iterator pattern with `map` to transform each character:\n\n- Checks if it's alphabetic using `is_alphabetic()`\n- Determines the base ('A' for uppercase, 'a' for lowercase)\n- Applies the Caesar cipher formula with modulo 26 for wrap-around\n- Collects the results into a new String\n\nHere's a chart of effort across the program's components:\n\n\`\`\`chartjs\n{\n  \"type\": \"bar\",\n  \"data\": {\n    \"labels\": [\"Input Handling\", \"Encryption Logic\", \"Output\"],\n    \"datasets\": [{\n      \"label\": \"Effort Allocation (%)\",\n      \"data\": [20, 70, 10],\n      \"backgroundColor\": \"#36A2EB\"\n    }]\n  },\n  \"options\": {\n    \"title\": {\n      \"display\": true,\n      \"text\": \"Program Flow Effort\"\n    },\n    \"scales\": {\n      \"y\": {\n        \"beginAtZero\": true,\n        \"max\": 100\n      }\n    }\n  }\n}\n\`\`\`\n\n### Key Insights\n\n- **Behavior First**: Running the code with inputs like 'abc' (shift 1 → 'bcd') revealed its cipher nature\n- **Functional Style**: Rust's iterator pattern made the encryption logic elegant and readable\n- **Memory Safety**: Rust's ownership system prevented common bugs while maintaining performance\n- **Pattern Matching**: Used `match` expressions for handling different character types\n- **Error Handling**: Rust's `Result` type ensured robust input validation\n\n### Rust-Specific Learning Points\n\n- **Ownership & Borrowing**: Understanding how `&str` and `String` work together\n- **Iterator Chains**: Using `chars()`, `map()`, and `collect()` for functional programming\n- **Type Safety**: Rust's type system caught potential overflow issues at compile time\n- **Pattern Matching**: Leveraging `match` for clean conditional logic\n- **Memory Efficiency**: Zero-cost abstractions made the code both safe and fast\n\n### Advanced Implementation\n\nHere's an enhanced version with better error handling:\n\n\`\`\`rust\nuse std::io;\n\nfn encrypt_advanced(text: &str, shift: i32) -> Result<String, &'static str> {\n    if shift < 0 || shift > 25 {\n        return Err(\"Shift must be between 0 and 25\");\n    }\n    \n    let result = text.chars()\n        .map(|c| match c {\n            'A'..='Z' => {\n                let shifted = (c as u8 - b'A' + shift as u8) % 26;\n                (b'A' + shifted) as char\n            },\n            'a'..='z' => {\n                let shifted = (c as u8 - b'a' + shift as u8) % 26;\n                (b'a' + shifted) as char\n            },\n            _ => c,\n        })\n        .collect();\n    \n    Ok(result)\n}\n\`\`\`\n\n### Lessons Learned\n\n- Reverse engineering starts with observing inputs and outputs to hypothesize purpose\n- Rust's functional programming features make complex transformations readable\n- The type system catches errors early, making reverse engineering safer\n- Pattern matching provides elegant solutions for character classification\n- Iterator chains are both performant and expressive in Rust\n\nThis exercise was a deep dive into Rust's unique approach to systems programming, combining memory safety with zero-cost abstractions. The Caesar cipher implementation showcased Rust's strengths in handling text processing while maintaining performance and safety!",
    "author": "Zinny",
    "date": "2025-06-10",
    "tags": ["Rust", "Reverse Engineering", "Caesar Cipher", "Systems Programming"],
    "headerImage": "/placeholder.svg?height=400&width=800",
    "contentImages": ["/placeholder.svg?height=300&width=600", "/placeholder.svg?height=300&width=600"]
  }
]

